/*
 * cocos2d for iPhone: http://www.cocos2d-iphone.org
 *
 * Copyright (c) 2008-2010 Ricardo Quesada
 * Copyright (c) 2011 Zynga Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
// ideas taken from:
//	 . The ocean spray in your face Jeff.Lander]
//		http://www.double.co.nz/dust/col0798.pdf
//	 . Building an Advanced Particle System John.van der Burg]
//		http://www.gamasutra.com/features/20000623/vanderburg_01.htm
//   . LOVE game engine
//		http://love2d.org/
//
//
// Radius mode support, from 71 squared
//		http://particledesigner.71squared.com/
//
// IMPORTANT: Particle Designer is supported by cocos2d, but
// 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,
//  cocos2d uses a another approach, but the results are almost identical. 
//
package cocos.particle;

import cocos.CCNode;
import cocos.CCTypes;
import cocos.CCConfig;
import cocos.CCTextureCache;
import cocos.CCMacros;
#if CC_ENABLE_PROFILERS
import cocos.support.CCProfiling;
#end
// support
using cocos.support.CGPointExtension;
import cocos.support.CGPointExtension;
import cocos.support.CCFileUtils;
import cocos.support.CGPoint;
import cocos.support.NSDictionary;
import cocos.support.UIImage;

/** @struct CC_Particle
 Structure that contains the values of each particle
 */
//
// Mode A: gravity, direction, radial accel, tangential accel
/*typedef A = {
	var dir :CGPoint;
	var radialAccel :Float;
	var tangentialAccel :Float;
}
// Mode B: radius mode
typedef B = {
	var angle :Float;
	var degreesPerSecond :Float;
	var radius :Float;
	var deltaRadius :Float;
}*/
// Mode A:Gravity + Tangential Accel + Radial Accel
typedef A = {
	var gravity :CGPoint;
	var speed :Float;
	var speedVar :Float;//variance
	var tangentialAccel :Float;
	var tangentialAccelVar :Float;
	var radialAccel :Float;
	var radialAccelVar :Float;
}
// Mode B: circular movement (gravity, radial accel and tangential accel are not used in this mode)
typedef B = {
	var startRadius :Float;
	var startRadiusVar :Float;
	var endRadius :Float;
	var endRadiusVar :Float ;
	var rotatePerSecond :Float;
	var rotatePerSecondVar :Float;
}
typedef Mode = {
	var A :A;
	var B :B;
}

typedef CC_Particle = {
	var pos :CGPoint;
	var startPos :CGPoint;
	var color :CC_Color4F;
	var deltaColor :CC_Color4F;
	var size :Float;
	var deltaSize :Float;
	var rotation :Float;
	var deltaRotation :Float;
	var timeToLive :Float;
	var mode :Dynamic;//A or B
}

typedef CC_UPDATE_PARTICLE_IMP = {
	var id:String;
	var SEL:Dynamic;
	var particle:CC_Particle;
	var point:CGPoint;
}


/** Particle System base class
 Attributes of a Particle System:
	- emmision rate of the particles
	- Gravity Mode (Mode A):
		- gravity
		- direction
		- speed +-  variance
		- tangential acceleration +- variance
		- radial acceleration +- variance
	- Radius Mode (Mode B):
		- startRadius +- variance
		- endRadius +- variance
		- rotate +- variance
	- Properties common to all modes:
		- life +- life variance
		- start spin +- variance
		- end spin +- variance
		- start size +- variance
		- end size +- variance
		- start color +- variance
		- end color +- variance
		- life +- variance
		- blending function
	- texture

 cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,
 cocos2d uses a another approach, but the results are almost identical. 

 cocos2d supports all the variables used by Particle Designer plus a bit more:
	- spinning particles (supported when using CCParticleSystemQuad)
	- tangential acceleration (Gravity mode)
	- radial acceleration (Gravity mode)
	- radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)

 It is possible to customize any of the above mentioned properties in runtime. Example:

 @code
	emitter.radialAccel = 15;
	emitter.startSpin = 0;
 }code

 */
class CCParticleSystem extends CCNode
{
	// This were enums
	inline static var kCCParticleModeGravity = 0;/** Gravity mode (A mode) */
	inline static var kCCParticleModeRadius = 1;/** Radius mode (B mode) */
	
	/** Living particles are attached to the world and are unaffected by emitter repositioning. */
	inline static var kCCPositionTypeFree = 0;
	/** Living particles are attached to the world but will follow the emitter repositioning.
	 Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite.*/
	inline static var kCCPositionTypeRelative = 1;
	/** Living particles are attached to the emitter and are translated along with it. */
	inline static var kCCPositionTypeGrouped = 2;
	
	/** The Particle emitter lives forever */
	inline static var kCCParticleDurationInfinity = 0;
	/** The starting size of the particle is equal to the ending size */
	inline static var kCCParticleStartSizeEqualToEndSize = 1;
	/** The starting radius of the particle is equal to the ending radius */
	inline static var kCCParticleStartRadiusEqualToEndRadius = 2;
	
	
	
	// is the particle system active ?
	public var active :Bool;
	// duration in seconds of the system. -1 is infinity
	public var duration :Float;
	// time elapsed since the start of the system (in seconds)
	public var elapsed :Float;
	
	// position is from "superclass" CocosNode
	public var sourcePosition :CGPoint;
	// Position variance
	public var posVar :CGPoint;

	// The angle (direction) of the particles measured in degrees
	public var angle :Float;
	// Angle variance measured in degrees;
	public var angleVar :Float;

	// Different modes
	/** Switch between different kind of emitter modes:
	   - kCCParticleModeGravity: uses gravity, speed, radial and tangential acceleration
	   - kCCParticleModeRadius: uses radius movement + rotation
	 */
	public var emitterMode :Int;// A or B
	var mode :Mode;

	// start ize of the particles
	var startSize :Float;
	// start Size variance
	var startSizeVar :Float;
	// End size of the particle
	var endSize :Float;
	// end size of variance
	var endSizeVar :Float;

	// How many seconds will the particle live
	var life :Float;
	// Life variance
	var lifeVar :Float;

	// Start color of the particles
	var startColor :CC_Color4F;
	// Start color variance
	var startColorVar :CC_Color4F;
	// End color of the particles
	var endColor :CC_Color4F;
	// End color variance
	var endColorVar :CC_Color4F;

	// start angle of the particles
	var startSpin :Float;
	// start angle variance
	var startSpinVar :Float;
	// End angle of the particle
	var endSpin :Float;
	// end angle ariance
	var endSpinVar :Float;


	// Array of particles
	var particles :Array<CC_Particle>;
	// Maximum particles
	public var totalParticles :Int;
	// Count of active particles
	public var particleCount :Int;

	// color modulate
//	var colorModulate :Bool;

	// How many particles can be emitted per second
	var emissionRate :Float;
	var emitCounter :Float;

	// Texture of the particles
	var texture_ :CCTexture2D;
	// blend function
	//var blendFunc :CC_BlendFunc;

	// movment type: free or grouped
	var positionType_ :Int;

	// Whether or not the node will be auto-removed when there are not particles
	//var autoRemoveOnFinish_ :Bool;

	//  particle idx
	var particleIdx :Int;

	// Optimization
	var updateParticleImp :CC_UPDATE_PARTICLE_IMP;
	var updateParticleSel :Dynamic;

// profiling
#if CC_ENABLE_PROFILERS
	var _profilingTimer :CCProfilingTimer;
#end

/** Is the emitter active */
//public var active (get_active, null) :Bool;
/** Quantity of particles that are being simulated at the moment */
//public var particleCount (get_particleCount, set_particleCount) :Int;
/** How many seconds the emitter wil run. -1 means 'forever' */
//public var duration (get_duration, set_duration) :Float;
/** sourcePosition of the emitter */
//public var sourcePosition (get_sourcePosition, set_sourcePosition) :CGPoint;
/** Position variance of the emitter */
//public var posVar (get_posVar, set_posVar) :CGPoint;
/** life, and life variation of each particle */
//public var life (get_life, set_life) :Float;
/** life variance of each particle */
//public var lifeVar (get_lifeVar, set_lifeVar) :Float;
/** angle and angle variation of each particle */
//public var angle (get_angle, set_angle) :Float;
/** angle variance of each particle */
//public var angleVar (get_angleVar, set_angleVar) :Float;

/** Gravity value. Only available in 'Gravity' mode. */
public var gravity (get_gravity, set_gravity) :CGPoint;
/** speed of each particle. Only available in 'Gravity' mode.  */
public var speed (get_speed, set_speed) :Float;
/** speed variance of each particle. Only available in 'Gravity' mode. */
public var speedVar (get_speedVar, set_speedVar) :Float;
/** tangential acceleration of each particle. Only available in 'Gravity' mode. */
public var tangentialAccel (get_tangentialAccel, set_tangentialAccel) :Float;
/** tangential acceleration variance of each particle. Only available in 'Gravity' mode. */
public var tangentialAccelVar (get_tangentialAccelVar, set_tangentialAccelVar) :Float;
/** radial acceleration of each particle. Only available in 'Gravity' mode. */
public var radialAccel (get_radialAccel, set_radialAccel) :Float;
/** radial acceleration variance of each particle. Only available in 'Gravity' mode. */
public var radialAccelVar (get_radialAccelVar, set_radialAccelVar) :Float;

/** The starting radius of the particles. Only available in 'Radius' mode. */
public var startRadius (get_startRadius, set_startRadius) :Float;
/** The starting radius variance of the particles. Only available in 'Radius' mode. */
public var startRadiusVar (get_startRadiusVar, set_startRadiusVar) :Float;
/** The ending radius of the particles. Only available in 'Radius' mode. */
public var endRadius (get_endRadius, set_endRadius) :Float;
/** The ending radius variance of the particles. Only available in 'Radius' mode. */
public var endRadiusVar (get_endRadiusVar, set_endRadiusVar) :Float;			
/** Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode. */
public var rotatePerSecond (get_rotatePerSecond, set_rotatePerSecond) :Float;
/** Variance in degrees for rotatePerSecond. Only available in 'Radius' mode. */
public var rotatePerSecondVar (get_rotatePerSecondVar, set_rotatePerSecondVar) :Float;

/** start size in pixels of each particle */
//public var startSize (get_startSize, set_startSize) :Float;
/** size variance in pixels of each particle */
//public var startSizeVar (get_startSizeVar, set_startSizeVar) :Float;
/** end size in pixels of each particle */
//public var endSize (get_endSize, set_endSize) :Float;
/** end size variance in pixels of each particle */
//public var endSizeVar (get_endSizeVar, set_endSizeVar) :Float;
/** start color of each particle */
//public var startColor (get_startColor, set_startColor) :CC_Color4F;
/** start color variance of each particle */
//public var startColorVar (get_startColorVar, set_startColorVar) :CC_Color4F;
/** end color and end color variation of each particle */
//public var endColor (get_endColor, set_endColor) :CC_Color4F;
/** end color variance of each particle */
//public var endColorVar (get_endColorVar, set_endColorVar) :CC_Color4F;
//* initial angle of each particle
//public var startSpin (get_startSpin, set_startSpin) :Float;
//* initial angle of each particle
//public var startSpinVar (get_startSpinVar, set_startSpinVar) :Float;
//* initial angle of each particle
//public var endSpin (get_endSpin, set_endSpin) :Float;
//* initial angle of each particle
//public var endSpinVar (get_endSpinVar, set_endSpinVar) :Float;
/** emission rate of the particles */
//public var emissionRate (get_emissionRate, set_emissionRate) :Float;
/** maximum particles of the system */
//public var totalParticles (get_totalParticles, set_totalParticles) :Int;
/** conforms to CocosNodeTexture protocol */
public var texture (get_texture, set_texture) :CCTexture2D;
/** conforms to CocosNodeTexture protocol */
public var blendFunc :CC_BlendFunc;
/** whether or not the particles are using blend additive.
 If enabled, the following blending function will be used.
 @code
	source blend function = GL.SRC_ALPHA;
	dest blend function = GL.ONE;
 }code
 */
public var blendAdditive (get_blendAdditive, set_blendAdditive) :Bool;
/** particles movement type: Free or Grouped
 @since v0.8
 */
public var positionType /*(get_positionType, set_positionType)*/ :Int;
/** whether or not the node will be auto-removed when it has no particles left.
 By default it is NO.
 @since v0.8
 */
public var autoRemoveOnFinish /*(get_autoRemoveOnFinish, set_autoRemoveOnFinish)*/ :Bool;



/** creates an initializes a CCParticleSystem from a plist file.
 This plist files can be creted manually or with Particle Designer:
	http://particledesigner.71squared.com/
 @since v0.99.3
 */
public static function particleWithFile (plistFile:String) :CCParticleSystem
{
	return new CCParticleSystem().initWithFile (plistFile);
}

/** initializes a CCParticleSystem from a plist file.
 This plist files can be creted manually or with Particle Designer:
	http://particledesigner.71squared.com/
 @since v0.99.3
 */
public function initWithFile (plistFile:String) :CCParticleSystem
{
	var path :String = CCFileUtils.fullPathFromRelativePath ( plistFile );
	var dict :NSDictionary = NSDictionary.dictionaryWithContentsOfFile ( path );
	
	if (dict == null) throw "Particles: file not found";
	return this.initWithDictionary ( dict );
}

/** initializes a CCQuadParticleSystem from a NSDictionary.
 @since v0.99.3
 */
//
public function initWithDictionary (dictionary:NSDictionary) :CCParticleSystem
{
	var maxParticles :Int = dictionary.valueForKey ( "maxParticles" );
	// this, not super
	this.initWithTotalParticles ( maxParticles );
	
	// angle
	angle = dictionary.valueForKey ( "angle" );
	angleVar = dictionary.valueForKey ( "angleVariance" );
	
	// duration
	duration = dictionary.valueForKey ( "duration" );
	
	// blend function
/*	blendFunc = {};
	blendFunc.src = dictionary.valueForKey ( "blendFuncSource" ).intValue;
	blendFunc.dst = dictionary.valueForKey ( "blendFuncDestination" ).intValue;*/
	
	// color
	var r:Float,g:Float,b:Float,a:Float;
	
	r = dictionary.valueForKey ( "startColorRed" );
	g = dictionary.valueForKey ( "startColorGreen" );
	b = dictionary.valueForKey ( "startColorBlue" );
	a = dictionary.valueForKey ( "startColorAlpha" );
	startColor = {r:r,g:g,b:b,a:a};
	
	r = dictionary.valueForKey ( "startColorVarianceRed" );
	g = dictionary.valueForKey ( "startColorVarianceGreen" );
	b = dictionary.valueForKey ( "startColorVarianceBlue" );
	a = dictionary.valueForKey ( "startColorVarianceAlpha" );
	startColorVar = {r:r,g:g,b:b,a:a};
	
	r = dictionary.valueForKey ( "finishColorRed" );
	g = dictionary.valueForKey ( "finishColorGreen" );
	b = dictionary.valueForKey ( "finishColorBlue" );
	a = dictionary.valueForKey ( "finishColorAlpha" );
	endColor = {r:r,g:g,b:b,a:a};
	
	r = dictionary.valueForKey ( "finishColorVarianceRed" );
	g = dictionary.valueForKey ( "finishColorVarianceGreen" );
	b = dictionary.valueForKey ( "finishColorVarianceBlue" );
	a = dictionary.valueForKey ( "finishColorVarianceAlpha" );
	endColorVar = {r:r,g:g,b:b,a:a};
	
	// particle size
	startSize = dictionary.valueForKey ( "startParticleSize" );
	startSizeVar = dictionary.valueForKey ( "startParticleSizeVariance" );
	endSize = dictionary.valueForKey ( "finishParticleSize" );
	endSizeVar = dictionary.valueForKey ( "finishParticleSizeVariance" );
	
	
	// position
	var x :Float = dictionary.valueForKey ( "sourcePositionx" );
	var y :Float = dictionary.valueForKey ( "sourcePositiony" );
	this.position = new CGPoint (x,y);
	posVar.x = dictionary.valueForKey ( "sourcePositionVariancex" );
	posVar.y = dictionary.valueForKey ( "sourcePositionVariancey" );
			
	
	// Spinning
	startSpin = dictionary.valueForKey ( "rotationStart" );
	startSpinVar = dictionary.valueForKey ( "rotationStartVariance" );
	endSpin = dictionary.valueForKey ( "rotationEnd" );
	endSpinVar = dictionary.valueForKey ( "rotationEndVariance" );
	
	emitterMode = dictionary.valueForKey ( "emitterType" );

	// Mode A: Gravity + tangential accel + radial accel
	mode = {
		A:{ gravity:new CGPoint(), speed:.0, speedVar:.0, tangentialAccel:.0, tangentialAccelVar:.0, radialAccel:.0, radialAccelVar:.0 },
		B:{startRadius:.0, startRadiusVar:.0, endRadius:.0, endRadiusVar:.0, rotatePerSecond:.0, rotatePerSecondVar:.0 }
	};
	
	if( emitterMode == kCCParticleModeGravity ) {
		// gravity
		mode.A.gravity.x = dictionary.valueForKey ( "gravityx" );
		mode.A.gravity.y = dictionary.valueForKey ( "gravityy" );
		
		//
		// speed
		mode.A.speed = dictionary.valueForKey ( "speed" );
		mode.A.speedVar = dictionary.valueForKey ( "speedVariance" );
		
		// radial acceleration			
		var tmp :Null<Float> = dictionary.valueForKey ( "radialAcceleration" );
		mode.A.radialAccel = tmp != null ? tmp : 0.0;
		
		tmp = dictionary.valueForKey ( "radialAccelVariance" );
		mode.A.radialAccelVar = tmp != null ? tmp : 0.0;
					
		// tangential acceleration
		tmp = dictionary.valueForKey ( "tangentialAcceleration" );
		mode.A.tangentialAccel = tmp != null ? tmp : 0.0;
		
		tmp = dictionary.valueForKey ( "tangentialAccelVariance" );
		mode.A.tangentialAccelVar = tmp != null ? tmp : 0.0;
	}
	
	
	// or Mode B: radius movement
	else if( emitterMode == kCCParticleModeRadius ) {
		var maxRadius :Float = dictionary.valueForKey ( "maxRadius" );
		var maxRadiusVar :Float = dictionary.valueForKey ( "maxRadiusVariance" );
		var minRadius :Float = dictionary.valueForKey ( "minRadius" );
		
		mode.B.startRadius = maxRadius;
		mode.B.startRadiusVar = maxRadiusVar;
		mode.B.endRadius = minRadius;
		mode.B.endRadiusVar = 0;
		mode.B.rotatePerSecond = dictionary.valueForKey ( "rotatePerSecond" );
		mode.B.rotatePerSecondVar = dictionary.valueForKey ( "rotatePerSecondVariance" );

	} else {
		throw "Invalid emitterType in config file";
	}
	
	// life span
	life = dictionary.valueForKey ( "particleLifespan" );
	lifeVar = dictionary.valueForKey ( "particleLifespanVariance" );				
	
	// emission Rate
	emissionRate = totalParticles/life;

	// texture		
	// Try to get the texture from the cache
	var textureName :String = dictionary.valueForKey ( "textureFileName" );

	var tex :CCTexture2D = CCTextureCache.sharedTextureCache().addImage ( textureName );

	if( tex != null )
		this.texture = tex;

	else {

		var textureData :String = dictionary.valueForKey ( "textureImageData" );
		if (textureData == null) throw "CCParticleSystem: Couldn't load texture";
		
		// if it fails, try to get it from the base64-gzipped data			
/*		var buffer :Dynamic = null;
		var len :Int = base64Decode((char*)textureData.UTF8String], (int)textureData.length], &buffer);
		if (buffer != null) throw "CCParticleSystem: error decoding textureImageData";
			
		var deflated :char = null;
		var deflatedLen :Int = ccInflateMemory(buffer, len, &deflated);
		
		if (deflated != null) throw "CCParticleSystem: error ungzipping textureImageData";
		var data :NSData = new NSData().initWithBytes ( deflated, deflatedLen );
		*/
		var data = null;
		var image :UIImage = new UIImage().initWithData ( data );

		this.texture = CCTextureCache.sharedTextureCache().addUIImage ( image, textureName );
		
		if (this.texture == null) throw "CCParticleSystem: error loading the texture";
	}
	
	return this;
}

//! Initializes a system with a fixed number of particles
public function initWithTotalParticles ( numberOfParticles:Int ) :CCParticleSystem
{
	super.init();

	totalParticles = numberOfParticles;
	
	particles[totalParticles] = null;
	
	// default, active
	active = true;
	
	// default blend function
	//blendFunc = { src:CCMacros.CC_BLEND_SRC, dst:CCMacros.CC_BLEND_DST };
	
	// default movement type;
	positionType_ = kCCPositionTypeFree;
	
	// by default be in mode A:
	emitterMode = kCCParticleModeGravity;
			
	// default: modulate
	// XXX: not used
//	colorModulate = true;
	
	autoRemoveOnFinish = false;

	// profiling
#if CC_ENABLE_PROFILERS
	_profilingTimer = CCProfiler.timerWithName("particle system", this);
#end
	
	// Optimization: compile udpateParticle method
	//updateParticleSel = updateQuadWithParticle(null, null);
	//updateParticleImp = this.methodForSelector ( updateParticleSel );
	
	// udpate after action in run!
	this.scheduleUpdateWithPriority ( 1 );
	
	return this;
}

override public function release () :Void
{
	particles = null;
	texture_.release();
	// profiling
#if CC_ENABLE_PROFILERS
	CCProfiler.releaseTimer ( _profilingTimer );
#end
	
	super.release();
}


//! Add a particle to the emitter
public function addParticle () :Bool
{
	if( this.isFull() )
		return false;
	
	var particle :CC_Particle = particles[ particleCount ];
	
	this.initParticle ( particle );		
	particleCount++;
	
	return true;
}
//! Initializes a particle
public function initParticle (particle:CC_Particle)
{
	// timeToLive
	// no negative life. prevent division by 0
	particle.timeToLive = life + lifeVar * CCMacros.RANDOM_MINUS1_1();
	particle.timeToLive = Math.max (0, particle.timeToLive);

	// position
	particle.pos.x = sourcePosition.x + posVar.x * CCMacros.RANDOM_MINUS1_1();
	particle.pos.x *= CCConfig.CC_CONTENT_SCALE_FACTOR;
	particle.pos.y = sourcePosition.y + posVar.y * CCMacros.RANDOM_MINUS1_1();
	particle.pos.y *= CCConfig.CC_CONTENT_SCALE_FACTOR;
	
	// Color
	var start :CC_Color4F = {
		r : CGPointExtension.clampf( startColor.r + startColorVar.r * CCMacros.RANDOM_MINUS1_1(), 0, 1),
		g : CGPointExtension.clampf( startColor.g + startColorVar.g * CCMacros.RANDOM_MINUS1_1(), 0, 1),
		b : CGPointExtension.clampf( startColor.b + startColorVar.b * CCMacros.RANDOM_MINUS1_1(), 0, 1),
		a : CGPointExtension.clampf( startColor.a + startColorVar.a * CCMacros.RANDOM_MINUS1_1(), 0, 1)
	};
	
	var end :CC_Color4F = {
		r : CGPointExtension.clampf( endColor.r + endColorVar.r * CCMacros.RANDOM_MINUS1_1(), 0, 1),
		g : CGPointExtension.clampf( endColor.g + endColorVar.g * CCMacros.RANDOM_MINUS1_1(), 0, 1),
		b : CGPointExtension.clampf( endColor.b + endColorVar.b * CCMacros.RANDOM_MINUS1_1(), 0, 1),
		a : CGPointExtension.clampf( endColor.a + endColorVar.a * CCMacros.RANDOM_MINUS1_1(), 0, 1)
	};
	
	particle.color = start;
	particle.deltaColor.r = (end.r - start.r) / particle.timeToLive;
	particle.deltaColor.g = (end.g - start.g) / particle.timeToLive;
	particle.deltaColor.b = (end.b - start.b) / particle.timeToLive;
	particle.deltaColor.a = (end.a - start.a) / particle.timeToLive;
	
	// size
	var startS :Float = startSize + startSizeVar * CCMacros.RANDOM_MINUS1_1();
	startS = Math.max(0, startS); // No negative value
	startS *= CCConfig.CC_CONTENT_SCALE_FACTOR;
	
	particle.size = startS;
	if( endSize == kCCParticleStartSizeEqualToEndSize )
		particle.deltaSize = 0;
	else {
		var endS :Float = endSize + endSizeVar * CCMacros.RANDOM_MINUS1_1();
		endS = Math.max(0, endS);	// No negative values
		endS *= CCConfig.CC_CONTENT_SCALE_FACTOR;
		particle.deltaSize = (endS - startS) / particle.timeToLive;
	}
	
	// rotation
	var startA :Float = startSpin + startSpinVar * CCMacros.RANDOM_MINUS1_1();
	var endA :Float = endSpin + endSpinVar * CCMacros.RANDOM_MINUS1_1();
	particle.rotation = startA;
	particle.deltaRotation = (endA - startA) / particle.timeToLive;
	
	// position
	if( positionType_ == kCCPositionTypeFree ) {
		var p :CGPoint = this.convertToWorldSpace (new CGPoint(0,0));
		particle.startPos = p.mult ( CCConfig.CC_CONTENT_SCALE_FACTOR );
	}
	else if( positionType_ == kCCPositionTypeRelative ) {
		particle.startPos = position_.mult ( CCConfig.CC_CONTENT_SCALE_FACTOR );
	}
	
	// direction
	var a :Float = CCMacros.CC_DEGREES_TO_RADIANS( angle + angleVar * CCMacros.RANDOM_MINUS1_1() );	
	
	// Mode Gravity: A
	if( emitterMode == kCCParticleModeGravity ) {

		var v :CGPoint = new CGPoint (Math.cos( a ), Math.sin( a ));
		var s :Float = mode.A.speed + mode.A.speedVar * CCMacros.RANDOM_MINUS1_1();
		s *= CCConfig.CC_CONTENT_SCALE_FACTOR;
		
		// direction
		particle.mode.A.dir = v.mult ( s );
		
		// radial accel
		particle.mode.A.radialAccel = mode.A.radialAccel + mode.A.radialAccelVar * CCMacros.RANDOM_MINUS1_1();
		particle.mode.A.radialAccel *= CCConfig.CC_CONTENT_SCALE_FACTOR;
		
		// tangential accel
		particle.mode.A.tangentialAccel = mode.A.tangentialAccel + mode.A.tangentialAccelVar * CCMacros.RANDOM_MINUS1_1();
		particle.mode.A.tangentialAccel *= CCConfig.CC_CONTENT_SCALE_FACTOR;

	}
	
	// Mode Radius: B
	else {
		// Set the default diameter of the particle from the source position
		var startRadius :Float = mode.B.startRadius + mode.B.startRadiusVar * CCMacros.RANDOM_MINUS1_1();
		var endRadius :Float = mode.B.endRadius + mode.B.endRadiusVar * CCMacros.RANDOM_MINUS1_1();

		startRadius *= CCConfig.CC_CONTENT_SCALE_FACTOR;
		endRadius *= CCConfig.CC_CONTENT_SCALE_FACTOR;
		
		particle.mode.B.radius = startRadius;

		if( mode.B.endRadius == kCCParticleStartRadiusEqualToEndRadius )
			particle.mode.B.deltaRadius = 0;
		else
			particle.mode.B.deltaRadius = (endRadius - startRadius) / particle.timeToLive;
	
		particle.mode.B.angle = a;
		particle.mode.B.degreesPerSecond = CCMacros.CC_DEGREES_TO_RADIANS (mode.B.rotatePerSecond + mode.B.rotatePerSecondVar * CCMacros.RANDOM_MINUS1_1());
	}	
}
//! stop emitting particles. Running particles will continue to run until they die
public function stopSystem ()
{
	active = false;
	elapsed = duration;
	emitCounter = 0;
}
//! Kill all living particles.
public function resetSystem ()
{
	active = true;
	elapsed = 0;
	for(particleIdx in 0...particleCount) {
		var p :CC_Particle = particles[particleIdx];
		p.timeToLive = 0;
	}
}
//! whether or not the system is full
inline public function isFull () :Bool
{
	return (particleCount == totalParticles);
}




// ParticleSystem - MainLoop
public function update ( dt:Float )
{
	if( active && emissionRate > 0 ) {
		var rate :Float = 1.0 / emissionRate;
		emitCounter += dt;
		while( particleCount < totalParticles && emitCounter > rate ) {
			this.addParticle();
			emitCounter -= rate;
		}
		
		elapsed += dt;
		if(duration != -1 && duration < elapsed)
			this.stopSystem();
	}
	
	particleIdx = 0;
	
	
#if CC_ENABLE_PROFILERS
	CCProfilingBeginTimingBlock (_profilingTimer);
#end
	
	
	var currentPosition :CGPoint = new CGPoint(0,0);
	
	if( positionType_ == kCCPositionTypeFree ) {
		currentPosition = this.convertToWorldSpace ( new CGPoint(0,0));
		currentPosition.x *= CCConfig.CC_CONTENT_SCALE_FACTOR;
		currentPosition.y *= CCConfig.CC_CONTENT_SCALE_FACTOR;
	}
	else if( positionType_ == kCCPositionTypeRelative ) {
		currentPosition = position_;
		currentPosition.x *= CCConfig.CC_CONTENT_SCALE_FACTOR;
		currentPosition.y *= CCConfig.CC_CONTENT_SCALE_FACTOR;
	}
	
	while( particleIdx < particleCount )
	{
		var p :CC_Particle = particles[particleIdx];
		
		// life
		p.timeToLive -= dt;

		if( p.timeToLive > 0 ) {
			
			// Mode A: gravity, direction, tangential accel & radial accel
			if( emitterMode == kCCParticleModeGravity ) {
				var tmp, radial, tangential :CGPoint;
				
				radial = new CGPoint(0,0);
				// radial acceleration
				if(p.pos.x > 0 || p.pos.y > 0)
					radial = p.pos.normalize();
				
				tangential = radial;
				radial = radial.mult ( p.mode.A.radialAccel );
				
				// tangential acceleration
				var newy :Float = tangential.x;
				tangential.x = - tangential.y;
				tangential.y = newy;
				tangential = tangential.mult ( p.mode.A.tangentialAccel );
				
				// (gravity + radial + tangential) * dt
				tmp = radial.add ( tangential ).add ( mode.A.gravity );
				tmp = tmp.mult ( dt );
				p.mode.A.dir = p.mode.A.dir.add ( tmp );
				tmp = p.mode.A.dir.mult ( dt );
				p.pos = p.pos.add ( tmp );
			}
			
			// Mode B: radius movement
			else {				
				// Update the angle and radius of the particle.
				p.mode.B.angle += p.mode.B.degreesPerSecond * dt;
				p.mode.B.radius += p.mode.B.deltaRadius * dt;
				
				p.pos.x = - Math.cos(p.mode.B.angle) * p.mode.B.radius;
				p.pos.y = - Math.sin(p.mode.B.angle) * p.mode.B.radius;
			}
			
			// color
			p.color.r += (p.deltaColor.r * dt);
			p.color.g += (p.deltaColor.g * dt);
			p.color.b += (p.deltaColor.b * dt);
			p.color.a += (p.deltaColor.a * dt);
			
			// size
			p.size += (p.deltaSize * dt);
			p.size = Math.max( 0, p.size );
			
			// angle
			p.rotation += (p.deltaRotation * dt);
						
			//
			// update values in quad
			//
			
			var newPos :CGPoint = null;
			
			if( positionType_ == kCCPositionTypeFree || positionType_ == kCCPositionTypeRelative ) {
				var diff :CGPoint = CGPointExtension.sub( currentPosition, p.startPos );
				newPos = CGPointExtension.sub(p.pos, diff);
				
			} else
				newPos = p.pos;

			
			updateParticleImp.SEL (this, updateParticleSel, p, newPos);
			
			// update particle counter
			particleIdx++;
			
		} else {
			// life < 0
			if( particleIdx != particleCount-1 )
				particles[particleIdx] = particles[particleCount-1];
			particleCount--;
			
			if( particleCount == 0 && autoRemoveOnFinish ) {
				this.unscheduleUpdate();
				parent.removeChild ( this, true );
				return;
			}
		}
	}
	
#if CC_ENABLE_PROFILERS
	CCProfilingEndTimingBlock(_profilingTimer);
#end
	
#if CC_USES_VBO
	this.postStep();
#end
}

public function updateQuadWithParticle (particle:CC_Particle, pos:CGPoint) :Void
{
	// should be overriden
}

public function postStep ()
{
	// should be overriden
}

// ParticleSystem - CCTexture protocol

public function set_texture (texture:CCTexture2D) :CCTexture2D
{
	if (texture_ != null)
		texture_.release();
	texture_ = texture;

	// If the new texture has No premultiplied alpha, AND the blendFunc hasn't been changed, then update it
	if( texture_ != null && ! texture.hasPremultipliedAlpha /*&&
		   ( blendFunc.src == CC_BLEND_SRC && blendFunc.dst == CC_BLEND_DST )*/)
	{
		blendFunc.src = GL.SRC_ALPHA;
		blendFunc.dst = GL.ONE_MINUS_SRC_ALPHA;
	}
	return texture_;
}

public function get_texture () :CCTexture2D
{
	return texture_;
}

// ParticleSystem - Additive Blending
public function set_blendAdditive ( additive:Bool ) :Bool
{
	if( additive ) {
		blendFunc.src = GL.SRC_ALPHA;
		blendFunc.dst = GL.ONE;

	} else {
		
/*		if( texture_ != null && ! texture_.hasPremultipliedAlpha ) {
			blendFunc.src = GL.SRC_ALPHA;
			blendFunc.dst = GL.ONE_MINUS_SRC_ALPHA;
		} else {
			blendFunc.src = CCMacros.CC_BLEND_SRC;
			blendFunc.dst = CCMacros.CC_BLEND_DST;
		}*/
	}
	return additive;
}

public function get_blendAdditive () :Bool
{
	return false;//( blendFunc.src == GL.SRC_ALPHA && blendFunc.dst == GL.ONE);
}

// ParticleSystem - Properties of Gravity Mode 
public function set_tangentialAccel ( t:Float ) :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.tangentialAccel = t;
}
public function get_tangentialAccel () :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.tangentialAccel;
}

public function set_tangentialAccelVar ( t:Float ) :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.tangentialAccelVar = t;
}
public function get_tangentialAccelVar () :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.tangentialAccelVar;
}

public function set_radialAccel ( t:Float ) :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.radialAccel = t;
}
public function get_radialAccel () :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.radialAccel;
}

public function set_radialAccelVar ( t:Float ) :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.radialAccelVar = t;
}
public function get_radialAccelVar () :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.radialAccelVar;
}

public function set_gravity ( g:CGPoint ) :CGPoint
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.gravity = g;
}
public function get_gravity () :CGPoint
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.gravity;
}

public function set_speed ( speed:Float ) :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.speed = speed;
}
public function get_speed () :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.speed;
}

public function set_speedVar ( speedVar:Float ) :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.speedVar = speedVar;
}
public function get_speedVar () :Float
{
	if (emitterMode != kCCParticleModeGravity) throw "Particle Mode should be Gravity";
	return mode.A.speedVar;
}

// ParticleSystem - Properties of Radius Mode

public function set_startRadius ( startRadius:Float ) :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.startRadius = startRadius;
}
public function get_startRadius () :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.startRadius;
}

public function set_startRadiusVar ( startRadiusVar:Float ) :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.startRadiusVar = startRadiusVar;
}
public function get_startRadiusVar () :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.startRadiusVar;
}

public function set_endRadius ( endRadius:Float ) :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.endRadius = endRadius;
}
public function get_endRadius () :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.endRadius;
}

public function set_endRadiusVar ( endRadiusVar:Float ) :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.endRadiusVar = endRadiusVar;
}
public function get_endRadiusVar () :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.endRadiusVar;
}

public function set_rotatePerSecond ( degrees:Float ) :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.rotatePerSecond = degrees;
}
public function get_rotatePerSecond () :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.rotatePerSecond;
}

public function set_rotatePerSecondVar ( degrees:Float ) :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.rotatePerSecondVar = degrees;
}
public function get_rotatePerSecondVar () :Float
{
	if (emitterMode != kCCParticleModeRadius) throw "Particle Mode should be Radius";
	return mode.B.rotatePerSecondVar;
}
}
